<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>RSA Шифрування/Дешифрування</title>
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="static/styles_4.css">
</head>
<body>
    <div class="container">
        <h1>RSA Шифрування/Дешифрування</h1>
       
        <div class="key-generation-section">
            <h2>Генерація ключів</h2>
            <div class="input-section">
                <label for="key-size">Розмір ключа (біт):</label>
                <div class="input-group">
                    <select id="key-size" class="input-field">
                        <option value="1024">1024</option>
                        <option value="2048" selected>2048</option>
                        <option value="3072">3072</option>
                        <option value="4096">4096</option>
                    </select>
                </div>
            </div>
            <button id="generate-keys-button" class="action-button">Генерувати ключі</button>
           
            <div class="keys-output-section" style="display: none;">
                <div class="input-section">
                    <label for="public-key">Публічний ключ:</label>
                    <div class="input-group">
                        <textarea id="public-key" class="key-textarea" placeholder="-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----" readonly></textarea>
                        <div class="button-group">
                            <button id="download-public-key" class="download-key-button">Завантажити</button>
                            <br>
                            <button id="copy-public-key" class="download-key-button">Копіювати</button>
                        </div>
                    </div>
                </div>
                <div class="input-section">
                    <label for="private-key">Приватний ключ:</label>
                    <div class="input-group">
                        <textarea id="private-key" class="key-textarea" placeholder="-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----" readonly></textarea>
                        <div class="button-group">
                            <button id="download-private-key" class="download-key-button">Завантажити</button>
                            <br>
                            <button id="copy-private-key" class="download-key-button">Копіювати</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="sections">
            <div class="section">
                <h2>Шифрування</h2>
              
                <div class="input-section">
                    <label for="encrypt-data">Введіть дані для шифрування:</label>
                    <div class="input-group">
                        <input id="encrypt-data" type="text" placeholder="Введіть текст" class="input-field">
                        <button id="encrypt-data-switch" class="switch-button">Вибрати файл</button>
                    </div>
                    <div id="encrypt-data-error" class="error"></div>
                </div>
                <div class="input-section">
                    <label>
                        <input type="checkbox" id="encrypt-hybrid"> Використовувати гібридний режим
                    </label>
                </div>
                <div class="input-section">
                    <label for="encrypt-public-key">Введіть публічний ключ:</label>
                    <div class="input-group">
                        <textarea id="encrypt-public-key" class="key-textarea" placeholder="-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----"></textarea>
                        <button id="encrypt-public-key-switch" class="switch-button">Вибрати файл з ключем</button>
                    </div>
                    <div id="encrypt-public-key-error" class="error"></div>
                </div>
                <button id="encrypt-button" class="action-button">Шифрувати</button>
            </div>
            <div class="section">
                <h2>Дешифрування</h2>
              
                <div class="input-section">
                    <label for="decrypt-data">Введіть дані для дешифрування (base64 або файл):</label>
                    <div class="input-group">
                        <input id="decrypt-data" type="text" placeholder="Введіть base64" class="input-field">
                        <button id="decrypt-data-switch" class="switch-button">Вибрати файл</button>
                    </div>
                    <div id="decrypt-data-error" class="error"></div>
                </div>
                <div class="input-section">
                    <label>
                        <input type="checkbox" id="decrypt-hybrid"> Використовувати гібридний режим
                    </label>
                </div>
                <div class="input-section">
                    <label for="decrypt-private-key">Введіть приватний ключ:</label>
                    <div class="input-group">
                        <textarea id="decrypt-private-key" class="key-textarea" placeholder="-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----"></textarea>
                        <button id="decrypt-private-key-switch" class="switch-button">Вибрати файл з ключем</button>
                    </div>
                    <div id="decrypt-private-key-error" class="error"></div>
                </div>
                <button id="decrypt-button" class="action-button">Дешифрувати</button>
            </div>
        </div>
        <div id="universal-result-section" class="universal-result-section">
            <h3>Результат</h3>
            <div id="universal-result" class="result"></div>
            <br><button id="copy-result" class="download-key-button" style="display: none;">Копіювати результат</button>
            <div id="tracking"></div>
            <button id="load-more" class="action-button" style="display: none;" onclick="loadMore()">Дозавантажити</button>
            <button id="download-button" class="download-button" style="display: none;">Завантажити файл</button>
        </div>
        <br>
        <a href="/" class="back-link">Назад до меню</a>
    </div>
    <script src="/config.js"></script>
    <script>
        let encryptDataIsFile = false;
        let encryptPublicKeyIsFile = false;
        let decryptDataIsFile = false;
        let decryptPrivateKeyIsFile = false;
        let currentBlob = null;
        let currentFilename = '';
        let resultChunks = [];
        let displayedChunkIndex = 0;
        const chunkSize = 32;
        const batchSize = 1;
       
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Помилка читання файлу ключа.'));
                reader.readAsText(file);
            });
        }
       
        function showError(elementId, message) {
            const errorElement = document.getElementById(elementId);
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
        function clearError(elementId) {
            const errorElement = document.getElementById(elementId);
            errorElement.textContent = '';
            errorElement.style.display = 'none';
        }
        function uint8ToString(uint8) {
            let str = '';
            const chars = new Array(uint8.length);
            for (let i = 0; i < uint8.length; ++i) {
                chars[i] = String.fromCharCode(uint8[i]);
            }
            str = chars.join('');
            return str;
        }
        function splitChunk(str) {
            let chunks = [];
            for (let i = 0; i < str.length; i += chunkSize) {
                chunks.push(str.slice(i, i + chunkSize));
            }
            return chunks;
        }
        function toggleInput(switchId, inputId, currentIsFile, buttonTextWhenTargetFile, buttonTextWhenTargetText, errorIds, placeholderText, placeholderFile, isTextarea = false) {
            const switchButton = document.getElementById(switchId);
            const inputContainer = document.getElementById(inputId).parentElement;
            const currentInput = document.getElementById(inputId);
            const targetIsFile = !currentIsFile;
            const newElementType = targetIsFile ? 'input' : (isTextarea ? 'textarea' : 'input');
            const newInput = document.createElement(newElementType);
            newInput.id = inputId;
            if (targetIsFile) {
                newInput.type = 'file';
                newInput.className = 'input-field';
                newInput.placeholder = placeholderFile;
            } else {
                if (isTextarea) {
                    newInput.className = 'key-textarea';
                    newInput.rows = 5;
                } else {
                    newInput.className = 'input-field';
                }
                newInput.placeholder = placeholderText;
            }
            inputContainer.replaceChild(newInput, currentInput);
            switchButton.textContent = targetIsFile ? buttonTextWhenTargetFile : buttonTextWhenTargetText;
            errorIds.forEach(id => clearError(id));
        }
        document.getElementById('encrypt-data-switch').addEventListener('click', () => {
            toggleInput('encrypt-data-switch', 'encrypt-data', encryptDataIsFile, 'Ввести текст', 'Вибрати файл', ['encrypt-data-error'], 'Введіть текст', '', false);
            encryptDataIsFile = !encryptDataIsFile;
        });
        document.getElementById('encrypt-public-key-switch').addEventListener('click', () => {
            toggleInput('encrypt-public-key-switch', 'encrypt-public-key', encryptPublicKeyIsFile, 'Ввести ключ', 'Вибрати файл з ключем', ['encrypt-public-key-error'], '-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----', '', true);
            encryptPublicKeyIsFile = !encryptPublicKeyIsFile;
        });
        document.getElementById('decrypt-data-switch').addEventListener('click', () => {
            toggleInput('decrypt-data-switch', 'decrypt-data', decryptDataIsFile, 'Ввести base64', 'Вибрати файл', ['decrypt-data-error'], 'Введіть base64', '', false);
            decryptDataIsFile = !decryptDataIsFile;
        });
        document.getElementById('decrypt-private-key-switch').addEventListener('click', () => {
            toggleInput('decrypt-private-key-switch', 'decrypt-private-key', decryptPrivateKeyIsFile, 'Ввести ключ', 'Вибрати файл з ключем', ['decrypt-private-key-error'], '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----', '', true);
            decryptPrivateKeyIsFile = !decryptPrivateKeyIsFile;
        });
        async function downloadBlob(blob, filename) {
            if (window.showSaveFilePicker) {
                const handle = await window.showSaveFilePicker({
                    suggestedName: filename,
                    types: [{ description: 'Binary Files', accept: { 'application/octet-stream': ['.enc', '.txt', '.pem'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
                return true;
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                return true;
            }
        }
        function loadMore() {
            const resultDiv = document.getElementById('universal-result');
            const numBatches = Math.min(batchSize, resultChunks.length - displayedChunkIndex);
            const nextBatch = resultChunks.slice(displayedChunkIndex, displayedChunkIndex + numBatches);
            resultDiv.textContent += nextBatch.join('');
            displayedChunkIndex += numBatches;
            const totalSymbols = resultChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            document.getElementById('tracking').textContent = `Відображено: ${resultDiv.textContent.length} з ${totalSymbols} символів`;
            document.getElementById('load-more').style.display = displayedChunkIndex < resultChunks.length ? 'inline-block' : 'none';
        }
        async function processStream(response, isEncrypt) {
            const reader = response.body.getReader();
            const fullChunks = [];
            const decoder = new TextDecoder();
            let remainder = '';
            resultChunks = [];
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    fullChunks.push(value);
                    let chunkStr;
                    if (isEncrypt) {
                        const uint8 = new Uint8Array(value);
                        const str = uint8ToString(uint8);
                        chunkStr = btoa(str);
                    } else {
                        const decoded = decoder.decode(value, { stream: !done });
                        if (remainder) {
                            chunkStr = remainder + decoded;
                            remainder = '';
                        } else {
                            chunkStr = decoded;
                        }
                        if (done && remainder) {
                            chunkStr += remainder;
                        }
                    }
                    const smallChunks = splitChunk(chunkStr);
                    resultChunks.push(...smallChunks);
                }
            }
            if (fullChunks.length > 0) {
                const totalLength = fullChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const fullArray = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of fullChunks) {
                    fullArray.set(new Uint8Array(chunk), offset);
                    offset += chunk.length;
                }
                return new Blob([fullArray]);
            }
            return new Blob([]);
        }
        async function showUniversalResult(isEncrypt, blob, filename, isFileInput) {
            const resultSection = document.getElementById('universal-result-section');
            const resultDiv = document.getElementById('universal-result');
            const downloadButton = document.getElementById('download-button');
            const loadMoreButton = document.getElementById('load-more');
            const tracking = document.getElementById('tracking');
            const copyResultButton = document.getElementById('copy-result');
            resultSection.style.display = 'block';
            downloadButton.style.display = 'inline-block';
            copyResultButton.style.display = 'inline-block';
            resultDiv.textContent = '';
            currentBlob = blob;
            currentFilename = filename;
            if (!isFileInput) {
                const buffer = await blob.arrayBuffer();
                let content;
                if (isEncrypt) {
                    const uint8 = new Uint8Array(buffer);
                    const str = uint8ToString(uint8);
                    content = btoa(str);
                } else {
                    const uint8 = new Uint8Array(buffer);
                    content = new TextDecoder('utf-8').decode(uint8);
                }
                resultDiv.textContent = content;
                loadMoreButton.style.display = 'none';
                tracking.textContent = '';
            } else {
                displayedChunkIndex = 0;
                loadMore();
                loadMoreButton.style.display = displayedChunkIndex < resultChunks.length ? 'inline-block' : 'none';
            }
        }
        function clearUniversalResult() {
            const resultSection = document.getElementById('universal-result-section');
            const resultDiv = document.getElementById('universal-result');
            const downloadButton = document.getElementById('download-button');
            const loadMoreButton = document.getElementById('load-more');
            const tracking = document.getElementById('tracking');
            const copyResultButton = document.getElementById('copy-result');
            resultSection.style.display = 'none';
            resultDiv.textContent = '';
            downloadButton.style.display = 'none';
            loadMoreButton.style.display = 'none';
            copyResultButton.style.display = 'none';
            tracking.textContent = '';
            resultChunks = [];
            displayedChunkIndex = 0;
            currentBlob = null;
            currentFilename = '';
        }
        document.getElementById('download-button').addEventListener('click', async () => {
            if (currentBlob && currentFilename) {
                await downloadBlob(currentBlob, currentFilename);
            }
        });
        function getTimestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}_${hours}${minutes}${seconds}`;
        }
        document.getElementById('generate-keys-button').addEventListener('click', async () => {
            const keySize = document.getElementById('key-size').value;
            try {
                const response = await fetch(`${CONFIG.API_URL_LAB_4}/generate_keys?bits=${keySize}`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Помилка генерації ключів');
                }
                const data = await response.json();
                document.getElementById('public-key').value = data.public_key;
                document.getElementById('private-key').value = data.private_key;
                document.querySelector('.keys-output-section').style.display = 'block';
            } catch (e) {
                alert(`Помилка генерації ключів: ${e.message}`);
            }
        });
        document.getElementById('download-public-key').addEventListener('click', async () => {
            const publicKeyText = document.getElementById('public-key').value;
            if (publicKeyText) {
                const blob = new Blob([publicKeyText], { type: 'text/plain' });
                await downloadBlob(blob, 'public_key.pem');
            }
        });
        document.getElementById('download-private-key').addEventListener('click', async () => {
            const privateKeyText = document.getElementById('private-key').value;
            if (privateKeyText) {
                const blob = new Blob([privateKeyText], { type: 'text/plain' });
                await downloadBlob(blob, 'private_key.pem');
            }
        });
        // Функція для копіювання тексту з тимчасовим повідомленням
        function copyToClipboard(text, buttonId) {
            navigator.clipboard.writeText(text).then(() => {
                const button = document.getElementById(buttonId);
                const originalText = button.textContent;
                button.textContent = 'Скопійовано!';
                button.style.backgroundColor = '#4CAF50'; // Зелений для успіху
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = ''; // Повернути оригінальний колір
                }, 2000);
            }).catch(err => {
                console.error('Помилка копіювання: ', err);
                alert('Не вдалося скопіювати текст. Спробуйте вручну.');
            });
        }
        // Копіювання ключів
        document.getElementById('copy-public-key').addEventListener('click', () => {
            const text = document.getElementById('public-key').value;
            if (text.trim()) {
                copyToClipboard(text, 'copy-public-key');
            } else {
                alert('Спочатку згенеруйте ключі.');
            }
        });
        document.getElementById('copy-private-key').addEventListener('click', () => {
            const text = document.getElementById('private-key').value;
            if (text.trim()) {
                copyToClipboard(text, 'copy-private-key');
            } else {
                alert('Спочатку згенеруйте ключі.');
            }
        });
        // Копіювання результату
        document.getElementById('copy-result').addEventListener('click', () => {
            const text = document.getElementById('universal-result').textContent;
            if (text.trim()) {
                copyToClipboard(text, 'copy-result');
            }
        });
        document.getElementById('encrypt-button').addEventListener('click', async () => {
            clearError('encrypt-data-error');
            clearError('encrypt-public-key-error');
            clearUniversalResult();
            const dataInput = document.getElementById('encrypt-data');
            const publicKeyInput = document.getElementById('encrypt-public-key');
            const hybridCheckbox = document.getElementById('encrypt-hybrid');
            const isFileInput = encryptDataIsFile;
            let hasError = false;
            if (isFileInput && (!dataInput.files || !dataInput.files.length)) {
                showError('encrypt-data-error', 'Виберіть файл для шифрування');
                hasError = true;
            } else if (!isFileInput && !dataInput.value.trim()) {
                showError('encrypt-data-error', 'Введіть дані для шифрування');
                hasError = true;
            }
            if (encryptPublicKeyIsFile && (!publicKeyInput.files || !publicKeyInput.files.length)) {
                showError('encrypt-public-key-error', 'Виберіть файл з публічним ключем');
                hasError = true;
            } else if (!encryptPublicKeyIsFile && !publicKeyInput.value.trim()) {
                showError('encrypt-public-key-error', 'Введіть публічний ключ');
                hasError = true;
            }
            if (hasError) return;
            try {
                const timestamp = getTimestamp();
                const formData = new FormData();
                if (!isFileInput) {
                    const text = dataInput.value.trim();
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(text);
                    const blob = new Blob([bytes], { type: 'text/plain' });
                    formData.append('data_file', blob, `input_${timestamp}.txt`);
                } else {
                    formData.append('data_file', dataInput.files[0]);
                }
                if (!encryptPublicKeyIsFile) {
                    const keyText = publicKeyInput.value.trim();
                    const keyBlob = new Blob([keyText], { type: 'text/plain' });
                    formData.append('public_key_file', keyBlob, `public_key_${timestamp}.pem`);
                } else {
                    formData.append('public_key_file', publicKeyInput.files[0]);
                }
                const hybridParam = hybridCheckbox.checked ? '?hybrid=true' : '';
                const response = await fetch(`${CONFIG.API_URL_LAB_4}/encrypt${hybridParam}`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Помилка API');
                }
                let blob;
                if (isFileInput) {
                    blob = await processStream(response, true);
                } else {
                    blob = await response.blob();
                }
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = `input_${timestamp}.enc`;
                if (hybridCheckbox.checked) {
                    filename = `input_${timestamp}_hybrid.enc`;
                }
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename\*\=UTF-8''([^;]+)/);
                    if (filenameMatch && filenameMatch[1]) {
                        filename = filenameMatch[1];
                    }
                }
                showUniversalResult(true, blob, filename, isFileInput);
            } catch (e) {
                clearUniversalResult();
                const errorMessage = e.message || e.toString();
              
                if (errorMessage.includes('no BEGIN PUBLIC KEY/END PUBLIC KEY delimiters')) {
                    showError('encrypt-public-key-error', 'Помилка шифрування: Невірний формат публічного ключа. Перевірте, чи це PEM-файл з delimiters BEGIN/END PUBLIC KEY.');
                } else if (errorMessage.includes('Unable to load PEM file') || errorMessage.includes('MalformedFraming')) {
                    showError('encrypt-public-key-error', 'Помилка шифрування: Невірний або пошкоджений публічний ключ. Спробуйте згенерувати новий.');
                } else {
                    showError('encrypt-data-error', `Помилка шифрування: ${errorMessage}`);
                }
            }
        });
        document.getElementById('decrypt-button').addEventListener('click', async () => {
            clearError('decrypt-data-error');
            clearError('decrypt-private-key-error');
            clearUniversalResult();
            const dataInput = document.getElementById('decrypt-data');
            const privateKeyInput = document.getElementById('decrypt-private-key');
            const hybridCheckbox = document.getElementById('decrypt-hybrid');
            const isFileInput = decryptDataIsFile;
            let hasError = false;
            if (isFileInput && (!dataInput.files || !dataInput.files.length)) {
                showError('decrypt-data-error', 'Виберіть файл для дешифрування');
                hasError = true;
            } else if (!isFileInput && !dataInput.value.trim()) {
                showError('decrypt-data-error', 'Введіть base64 для дешифрування');
                hasError = true;
            }
            if (decryptPrivateKeyIsFile && (!privateKeyInput.files || !privateKeyInput.files.length)) {
                showError('decrypt-private-key-error', 'Виберіть файл з приватним ключем');
                hasError = true;
            } else if (!decryptPrivateKeyIsFile && !privateKeyInput.value.trim()) {
                showError('decrypt-private-key-error', 'Введіть приватний ключ');
                hasError = true;
            }
            if (hasError) return;
            let keyText = '';
            if (decryptPrivateKeyIsFile) {
                try {
                    keyText = await readFileAsText(privateKeyInput.files[0]);
                } catch (e) {
                    showError('decrypt-private-key-error', e.message);
                    return;
                }
            } else {
                keyText = privateKeyInput.value.trim();
            }
            if (keyText.includes('-----BEGIN PUBLIC KEY-----')) {
                showError('decrypt-private-key-error', 'Помилка дешифрування: Введено публічний ключ замість приватного. Використовуйте приватний ключ для дешифрування.');
                return;
            }
            try {
                const timestamp = getTimestamp();
                const formData = new FormData();
                if (!isFileInput) {
                    const base64 = dataInput.value.trim();
                    try {
                        const binaryString = atob(base64);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const blob = new Blob([bytes], { type: 'application/octet-stream' });
                        formData.append('encrypted_file', blob, `input_${timestamp}.enc`);
                    } catch (decodeError) {
                        throw new Error('Невірний формат base64');
                    }
                } else {
                    formData.append('encrypted_file', dataInput.files[0]);
                }
                if (!decryptPrivateKeyIsFile) {
                    const keyBlob = new Blob([keyText], { type: 'text/plain' });
                    formData.append('private_key_file', keyBlob, `private_key_${timestamp}.pem`);
                } else {
                    formData.append('private_key_file', privateKeyInput.files[0]);
                }
                const hybridParam = hybridCheckbox.checked ? '?hybrid=true' : '';
                const response = await fetch(`${CONFIG.API_URL_LAB_4}/decrypt${hybridParam}`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Помилка API');
                }
                let blob;
                if (isFileInput) {
                    blob = await processStream(response, false);
                } else {
                    blob = await response.blob();
                }
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = `input_${timestamp}.txt`;
                if (hybridCheckbox.checked) {
                    filename = `input_${timestamp}_hybrid.txt`;
                }
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename\*\=UTF-8''([^;]+)/);
                    if (filenameMatch && filenameMatch[1]) {
                        filename = filenameMatch[1];
                    }
                }
                showUniversalResult(false, blob, filename, isFileInput);
            } catch (e) {
                clearUniversalResult();
                const errorMessage = e.message || e.toString();
              
                if (errorMessage.includes('no BEGIN PRIVATE KEY/END PRIVATE KEY delimiters')) {
                    showError('decrypt-private-key-error', 'Помилка дешифрування: Невірний формат приватного ключа. Перевірте, чи це PEM-файл з delimiters BEGIN/END PRIVATE KEY.');
                } else if (errorMessage.includes('Unable to load PEM file') || errorMessage.includes('MalformedFraming')) {
                    showError('decrypt-private-key-error', 'Помилка дешифрування: Невірний або пошкоджений приватний ключ. Спробуйте згенерувати новий.');
                } else if (errorMessage.includes('Invalid key size') && errorMessage.includes('AES')) {
                    showError('decrypt-data-error', 'Помилка дешифрування: Файл не зашифровано гібридним режимом. Увімкніть звичайний режим дешифрування.');
                } else if (errorMessage.includes('Decryption failed') && !errorMessage.includes('AES')) {
                    showError('decrypt-data-error', 'Помилка дешифрування: Файл зашифровано гібридним режимом. Увімкніть гібридний режим дешифрування.');
                } else if (errorMessage === 'Failed to fetch') {
                    showError('decrypt-data-error', 'Помилка дешифрування: Файл пошкоджено або невірний ключ. Спробуйте інший файл/ключ.');
                } else {
                    showError('decrypt-data-error', `Помилка дешифрування: ${errorMessage}`);
                }
            }
        });
    </script>
</body>
</html>