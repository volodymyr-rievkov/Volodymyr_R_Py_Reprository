<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>DSA Підпис/Верифікація</title>
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/static/styles_5.css">
</head>
<body>
    <div class="container">
        <h1>DSA Підпис/Верифікація</h1>
      
        <div class="key-generation-section">
            <h2>Генерація ключів</h2>
            <div class="input-section">
                <label for="key-size">Розмір ключа (біт):</label>
                <div class="input-group">
                    <select id="key-size" class="input-field">
                        <option value="1024">1024</option>
                        <option value="2048" selected>2048</option>
                        <option value="3072">3072</option>
                        <option value="4096">4096</option>
                    </select>
                </div>
            </div>
            <button id="generate-keys-button" class="action-button">Генерувати ключі</button>
          
            <div class="keys-output-section" style="display: none;">
<div class="input-section">
                    <label for="private-key">Приватний ключ:</label>
                    <div class="input-group">
                        <textarea id="private-key" class="key-textarea" placeholder="-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----" readonly></textarea>
                        <div class="button-group">
                            <button id="download-private-key" class="download-key-button">Завантажити</button>
                            <br>
                            <button id="copy-private-key" class="download-key-button">Копіювати</button>
                        </div>
                    </div>
                </div>
                <div class="input-section">
                    <label for="public-key">Публічний ключ:</label>
                    <div class="input-group">
                        <textarea id="public-key" class="key-textarea" placeholder="-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----" readonly></textarea>
                        <div class="button-group">
                            <button id="download-public-key" class="download-key-button">Завантажити</button>
                            <br>
                            <button id="copy-public-key" class="download-key-button">Копіювати</button>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="sections">
            <div class="section">
                <h2>Генерація підпису</h2>
             
                <div class="input-section">
                    <label for="sign-data">Введіть дані для підпису:</label>
                    <div class="input-group">
                        <input id="sign-data" type="text" placeholder="Введіть текст" class="input-field">
                        <button id="sign-data-switch" class="switch-button">Вибрати файл</button>
                    </div>
                    <div id="sign-data-error" class="error"></div>
                </div>
                <div class="input-section">
                    <label for="sign-private-key">Введіть приватний ключ:</label>
                    <div class="input-group">
                        <textarea id="sign-private-key" class="key-textarea" placeholder="-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----"></textarea>
                        <button id="sign-private-key-switch" class="switch-button">Вибрати файл з ключем</button>
                    </div>
                    <div id="sign-private-key-error" class="error"></div>
                </div>
                <button id="sign-button" class="action-button">Підписати</button>
            </div>
            <div class="section">
                <h2>Верифікація</h2>
                <div class="input-section">
                    <label for="verify-data">Введіть дані для верифікації (текст або файл):</label>
                    <div class="input-group">
                        <input id="verify-data" type="text" placeholder="Введіть текст" class="input-field">
                        <button id="verify-data-switch" class="switch-button">Вибрати файл</button>
                    </div>
                    <div id="verify-data-error" class="error"></div>
                </div>
                <div class="input-section">
                    <label for="verify-public-key">Введіть публічний ключ:</label>
                    <div class="input-group">
                        <textarea id="verify-public-key" class="key-textarea" placeholder="-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----"></textarea>
                        <button id="verify-public-key-switch" class="switch-button">Вибрати файл з ключем</button>
                    </div>
                    <div id="verify-public-key-error" class="error"></div>
                </div>
                <div class="input-section">
                    <label for="verify-signature">Введіть цифровий підпис (hex або файл):</label>
                    <div class="input-group">
                        <input id="verify-signature" type="text" placeholder="Введіть hex (16-кове число)" class="input-field">
                        <button id="verify-signature-switch" class="switch-button">Вибрати файл з підписом</button>
                    </div>
                    <div id="verify-signature-error" class="error"></div>
                </div>
                <button id="verify-button" class="action-button">Верифікувати</button>
            </div>
        </div>
        <div id="universal-result-section" class="universal-result-section">
            <h3>Результат</h3>
            <div id="universal-result" class="result"></div>
            <br><button id="copy-result" class="download-key-button" style="display: none;">Копіювати результат</button>
            <div id="tracking"></div>
            <button id="load-more" class="action-button" style="display: none;" onclick="loadMore()">Дозавантажити</button>
            <button id="download-button" class="download-button" style="display: none;">Завантажити файл</button>
        </div>
        <br>
        <a href="/" class="back-link">Назад до меню</a>
    </div>
    <script src="/config.js"></script>
    <script>
        let signDataIsFile = false;
        let signPrivateKeyIsFile = false;
        let verifyDataIsFile = false;
        let verifySignatureIsFile = false;
        let verifyPublicKeyIsFile = false;
        let currentBlob = null;
        let currentFilename = '';
        let resultChunks = [];
        let displayedChunkIndex = 0;
        const chunkSize = 32;
        const batchSize = 1;
      
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Помилка читання файлу ключа.'));
                reader.readAsText(file);
            });
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Помилка читання файлу.'));
                reader.readAsArrayBuffer(file);
            });
        }
      
        function showError(elementId, message) {
            const errorElement = document.getElementById(elementId);
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
        function clearError(elementId) {
            const errorElement = document.getElementById(elementId);
            errorElement.textContent = '';
            errorElement.style.display = 'none';
        }

        function uint8ToHex(uint8) {
            return Array.from(uint8, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        function hexToUint8(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }

        function splitChunk(str) {
            let chunks = [];
            for (let i = 0; i < str.length; i += chunkSize) {
                chunks.push(str.slice(i, i + chunkSize));
            }
            return chunks;
        }

        function toggleInput(switchId, inputId, currentIsFile, buttonTextWhenTargetFile, buttonTextWhenTargetText, errorIds, placeholderText, placeholderFile, isTextarea = false) {
            const switchButton = document.getElementById(switchId);
            const inputContainer = document.getElementById(inputId).parentElement;
            const currentInput = document.getElementById(inputId);
            const targetIsFile = !currentIsFile;
            const newElementType = targetIsFile ? 'input' : (isTextarea ? 'textarea' : 'input');
            const newInput = document.createElement(newElementType);
            newInput.id = inputId;
            if (targetIsFile) {
                newInput.type = 'file';
                newInput.className = 'input-field';
                newInput.placeholder = placeholderFile;
            } else {
                if (isTextarea) {
                    newInput.className = 'key-textarea';
                    newInput.rows = 5;
                } else {
                    newInput.className = 'input-field';
                }
                newInput.placeholder = placeholderText;
            }
            inputContainer.replaceChild(newInput, currentInput);
            switchButton.textContent = targetIsFile ? buttonTextWhenTargetFile : buttonTextWhenTargetText;
            errorIds.forEach(id => clearError(id));
        }

        document.getElementById('sign-data-switch').addEventListener('click', () => {
            toggleInput('sign-data-switch', 'sign-data', signDataIsFile, 'Ввести текст', 'Вибрати файл', ['sign-data-error'], 'Введіть текст', '', false);
            signDataIsFile = !signDataIsFile;
        });

        document.getElementById('sign-private-key-switch').addEventListener('click', () => {
            toggleInput('sign-private-key-switch', 'sign-private-key', signPrivateKeyIsFile, 'Ввести ключ', 'Вибрати файл з ключем', ['sign-private-key-error'], '-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----', '', true);
            signPrivateKeyIsFile = !signPrivateKeyIsFile;
        });

        document.getElementById('verify-data-switch').addEventListener('click', () => {
            toggleInput('verify-data-switch', 'verify-data', verifyDataIsFile, 'Ввести текст', 'Вибрати файл', ['verify-data-error'], 'Введіть текст', '', false);
            verifyDataIsFile = !verifyDataIsFile;
        });

        document.getElementById('verify-signature-switch').addEventListener('click', () => {
            toggleInput('verify-signature-switch', 'verify-signature', verifySignatureIsFile, 'Ввести hex', 'Вибрати файл з підписом', ['verify-signature-error'], 'Введіть hex (16-кове число)', '', false);
            verifySignatureIsFile = !verifySignatureIsFile;
        });

        document.getElementById('verify-public-key-switch').addEventListener('click', () => {
            toggleInput('verify-public-key-switch', 'verify-public-key', verifyPublicKeyIsFile, 'Ввести ключ', 'Вибрати файл з ключем', ['verify-public-key-error'], '-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----', '', true);
            verifyPublicKeyIsFile = !verifyPublicKeyIsFile;
        });

        async function downloadBlob(blob, filename) {
            if (window.showSaveFilePicker) {
                const handle = await window.showSaveFilePicker({
                    suggestedName: filename,
                    types: [{ description: 'Binary Files', accept: { 'application/octet-stream': ['.sig', '.txt', '.pem'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
                return true;
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                return true;
            }
        }

        function loadMore() {
            const resultDiv = document.getElementById('universal-result');
            const numBatches = Math.min(batchSize, resultChunks.length - displayedChunkIndex);
            const nextBatch = resultChunks.slice(displayedChunkIndex, displayedChunkIndex + numBatches);
            resultDiv.textContent += nextBatch.join('');
            displayedChunkIndex += numBatches;
            const totalSymbols = resultChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            document.getElementById('tracking').textContent = `Відображено: ${resultDiv.textContent.length} з ${totalSymbols} символів`;
            document.getElementById('load-more').style.display = displayedChunkIndex < resultChunks.length ? 'inline-block' : 'none';
        }

        async function processStream(response) {
            const reader = response.body.getReader();
            const fullChunks = [];
            let remainder = '';
            resultChunks = [];
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    fullChunks.push(value);
                    const uint8 = new Uint8Array(value);
                    const hexChunk = uint8ToHex(uint8);
                    const smallChunks = splitChunk(hexChunk);
                    resultChunks.push(...smallChunks);
                }
            }
            if (fullChunks.length > 0) {
                const totalLength = fullChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const fullArray = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of fullChunks) {
                    fullArray.set(new Uint8Array(chunk), offset);
                    offset += chunk.length;
                }
                return new Blob([fullArray]);
            }
            return new Blob([]);
        }

        async function showUniversalResult(isSign, blob, filename, isFileInput, verifyResult = null) {
            const resultSection = document.getElementById('universal-result-section');
            const resultDiv = document.getElementById('universal-result');
            const downloadButton = document.getElementById('download-button');
            const loadMoreButton = document.getElementById('load-more');
            const tracking = document.getElementById('tracking');
            const copyResultButton = document.getElementById('copy-result');
            resultSection.style.display = 'block';
            downloadButton.style.display = 'inline-block';
            copyResultButton.style.display = 'inline-block';
            resultDiv.textContent = '';
            currentBlob = blob;
            currentFilename = filename;

            if (verifyResult !== null) {
                // Для верифікації: просто текстовий результат
                resultDiv.textContent = verifyResult ? 'Підпис дійсний ✅' : 'Підпис недійсний ❌';
                loadMoreButton.style.display = 'none';
                tracking.textContent = '';
                downloadButton.style.display = 'none'; // Не завантажуємо для verify
            } else if (!isFileInput) {
                const buffer = await blob.arrayBuffer();
                const uint8 = new Uint8Array(buffer);
                const hex = uint8ToHex(uint8);
                resultDiv.textContent = hex;
                loadMoreButton.style.display = 'none';
                tracking.textContent = '';
            } else {
                displayedChunkIndex = 0;
                loadMore();
                loadMoreButton.style.display = displayedChunkIndex < resultChunks.length ? 'inline-block' : 'none';
            }
        }

        function clearUniversalResult() {
            const resultSection = document.getElementById('universal-result-section');
            const resultDiv = document.getElementById('universal-result');
            const downloadButton = document.getElementById('download-button');
            const loadMoreButton = document.getElementById('load-more');
            const tracking = document.getElementById('tracking');
            const copyResultButton = document.getElementById('copy-result');
            resultSection.style.display = 'none';
            resultDiv.textContent = '';
            downloadButton.style.display = 'none';
            loadMoreButton.style.display = 'none';
            copyResultButton.style.display = 'none';
            tracking.textContent = '';
            resultChunks = [];
            displayedChunkIndex = 0;
            currentBlob = null;
            currentFilename = '';
        }

        document.getElementById('download-button').addEventListener('click', async () => {
            if (currentBlob && currentFilename) {
                await downloadBlob(currentBlob, currentFilename);
            }
        });

        function getTimestamp() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}_${hours}${minutes}${seconds}`;
        }

        document.getElementById('generate-keys-button').addEventListener('click', async () => {
            const keySize = document.getElementById('key-size').value;
            try {
                const response = await fetch(`${CONFIG.API_URL_LAB_5}/generate_keys?bits=${keySize}`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Помилка генерації ключів');
                }
                const data = await response.json();
                document.getElementById('public-key').value = data.public_key;
                document.getElementById('private-key').value = data.private_key;
                document.querySelector('.keys-output-section').style.display = 'block';
            } catch (e) {
                alert(`Помилка генерації ключів: ${e.message}`);
            }
        });

        document.getElementById('download-public-key').addEventListener('click', async () => {
            const publicKeyText = document.getElementById('public-key').value;
            if (publicKeyText) {
                const blob = new Blob([publicKeyText], { type: 'text/plain' });
                await downloadBlob(blob, 'public_key.pem');
            }
        });

        document.getElementById('download-private-key').addEventListener('click', async () => {
            const privateKeyText = document.getElementById('private-key').value;
            if (privateKeyText) {
                const blob = new Blob([privateKeyText], { type: 'text/plain' });
                await downloadBlob(blob, 'private_key.pem');
            }
        });

        // Функція для копіювання тексту з тимчасовим повідомленням
        function copyToClipboard(text, buttonId) {
            navigator.clipboard.writeText(text).then(() => {
                const button = document.getElementById(buttonId);
                const originalText = button.textContent;
                button.textContent = 'Скопійовано!';
                button.style.backgroundColor = '#4CAF50'; // Зелений для успіху
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = ''; // Повернути оригінальний колір
                }, 2000);
            }).catch(err => {
                console.error('Помилка копіювання: ', err);
                alert('Не вдалося скопіювати текст. Спробуйте вручну.');
            });
        }

        // Копіювання ключів
        document.getElementById('copy-public-key').addEventListener('click', () => {
            const text = document.getElementById('public-key').value;
            if (text.trim()) {
                copyToClipboard(text, 'copy-public-key');
            } else {
                alert('Спочатку згенеруйте ключі.');
            }
        });

        document.getElementById('copy-private-key').addEventListener('click', () => {
            const text = document.getElementById('private-key').value;
            if (text.trim()) {
                copyToClipboard(text, 'copy-private-key');
            } else {
                alert('Спочатку згенеруйте ключі.');
            }
        });

        // Копіювання результату
        document.getElementById('copy-result').addEventListener('click', () => {
            const text = document.getElementById('universal-result').textContent;
            if (text.trim()) {
                copyToClipboard(text, 'copy-result');
            }
        });

        document.getElementById('sign-button').addEventListener('click', async () => {
            clearError('sign-data-error');
            clearError('sign-private-key-error');
            clearUniversalResult();
            const dataInput = document.getElementById('sign-data');
            const privateKeyInput = document.getElementById('sign-private-key');
            const isFileInput = signDataIsFile;
            let hasError = false;
            if (isFileInput && (!dataInput.files || !dataInput.files.length)) {
                showError('sign-data-error', 'Виберіть файл для підпису');
                hasError = true;
            } else if (!isFileInput && !dataInput.value.trim()) {
                showError('sign-data-error', 'Введіть дані для підпису');
                hasError = true;
            }
            if (signPrivateKeyIsFile && (!privateKeyInput.files || !privateKeyInput.files.length)) {
                showError('sign-private-key-error', 'Виберіть файл з приватним ключем');
                hasError = true;
            } else if (!signPrivateKeyIsFile && !privateKeyInput.value.trim()) {
                showError('sign-private-key-error', 'Введіть приватний ключ');
                hasError = true;
            }
            if (hasError) return;
            try {
                const timestamp = getTimestamp();
                const formData = new FormData();
                if (!isFileInput) {
                    const text = dataInput.value.trim();
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(text);
                    const blob = new Blob([bytes], { type: 'text/plain' });
                    formData.append('data_file', blob, `input_${timestamp}.txt`);
                } else {
                    formData.append('data_file', dataInput.files[0]);
                }
                if (!signPrivateKeyIsFile) {
                    const keyText = privateKeyInput.value.trim();
                    const keyBlob = new Blob([keyText], { type: 'text/plain' });
                    formData.append('private_key_file', keyBlob, `private_key_${timestamp}.pem`);
                } else {
                    formData.append('private_key_file', privateKeyInput.files[0]);
                }
                const response = await fetch(`${CONFIG.API_URL_LAB_5}/sign`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Помилка API');
                }
                let blob;
                if (isFileInput) {
                    blob = await processStream(response);
                } else {
                    blob = await response.blob();
                }
                const filename = `signature_${timestamp}.der`;
                showUniversalResult(true, blob, filename, isFileInput);
            } catch (e) {
                clearUniversalResult();
                const errorMessage = e.message || e.toString();
                if (errorMessage.includes('no BEGIN PRIVATE KEY/END PRIVATE KEY delimiters')) {
                    showError('sign-private-key-error', 'Помилка підпису: Невірний формат приватного ключа. Перевірте, чи це PEM-файл з delimiters BEGIN/END PRIVATE KEY.');
                } else if (errorMessage.includes('Unable to load PEM file') || errorMessage.includes('MalformedFraming')) {
                    showError('sign-private-key-error', 'Помилка підпису: Невірний або пошкоджений приватний ключ. Спробуйте згенерувати новий.');
                } else {
                    showError('sign-data-error', `Помилка підпису: ${errorMessage}`);
                }
            }
        });

        document.getElementById('verify-button').addEventListener('click', async () => {
            clearError('verify-data-error');
            clearError('verify-signature-error');
            clearError('verify-public-key-error');
            clearUniversalResult();
            const dataInput = document.getElementById('verify-data');
            const signatureInput = document.getElementById('verify-signature');
            const publicKeyInput = document.getElementById('verify-public-key');
            const isDataFile = verifyDataIsFile;
            const isSignatureFile = verifySignatureIsFile;
            let hasError = false;
            if (isDataFile && (!dataInput.files || !dataInput.files.length)) {
                showError('verify-data-error', 'Виберіть файл для верифікації');
                hasError = true;
            } else if (!isDataFile && !dataInput.value.trim()) {
                showError('verify-data-error', 'Введіть дані для верифікації');
                hasError = true;
            }
            if (isSignatureFile && (!signatureInput.files || !signatureInput.files.length)) {
                showError('verify-signature-error', 'Виберіть файл з підписом');
                hasError = true;
            } else if (!isSignatureFile && !signatureInput.value.trim()) {
                showError('verify-signature-error', 'Введіть hex підпису');
                hasError = true;
            }
            if (verifyPublicKeyIsFile && (!publicKeyInput.files || !publicKeyInput.files.length)) {
                showError('verify-public-key-error', 'Виберіть файл з публічним ключем');
                hasError = true;
            } else if (!verifyPublicKeyIsFile && !publicKeyInput.value.trim()) {
                showError('verify-public-key-error', 'Введіть публічний ключ');
                hasError = true;
            }
            if (hasError) return;

            let signatureBytes;
            if (!isSignatureFile) {
                try {
                    const hex = signatureInput.value.trim().replace(/\s/g, ''); // Видаляємо пробіли
                    if (!/^[0-9a-fA-F]+$/.test(hex)) {
                        throw new Error('Невірний формат hex');
                    }
                    signatureBytes = hexToUint8(hex);
                } catch (e) {
                    showError('verify-signature-error', 'Невірний формат hex підпису');
                    return;
                }
            }

            try {
                const timestamp = getTimestamp();
                const formData = new FormData();
                if (!isDataFile) {
                    const text = dataInput.value.trim();
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(text);
                    const blob = new Blob([bytes], { type: 'text/plain' });
                    formData.append('data_file', blob, `input_${timestamp}.txt`);
                } else {
                    formData.append('data_file', dataInput.files[0]);
                }
                if (!isSignatureFile) {
                    const signatureBlob = new Blob([signatureBytes], { type: 'application/octet-stream' });
                    formData.append('signature_file', signatureBlob, `signature_${timestamp}.der`);
                } else {
                    formData.append('signature_file', signatureInput.files[0]);
                }
                if (!verifyPublicKeyIsFile) {
                    const keyText = publicKeyInput.value.trim();
                    const keyBlob = new Blob([keyText], { type: 'text/plain' });
                    formData.append('public_key_file', keyBlob, `public_key_${timestamp}.pem`);
                } else {
                    formData.append('public_key_file', publicKeyInput.files[0]);
                }
                const response = await fetch(`${CONFIG.API_URL_LAB_5}/verify`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Помилка API');
                }
                const result = await response.json();
                const filename = `verify_result_${timestamp}.json`; // Не використовується, бо немає download
                showUniversalResult(false, null, filename, false, result.valid);
            } catch (e) {
                clearUniversalResult();
                const errorMessage = e.message || e.toString();
                if (errorMessage.includes('no BEGIN PUBLIC KEY/END PUBLIC KEY delimiters')) {
                    showError('verify-public-key-error', 'Помилка верифікації: Невірний формат публічного ключа. Перевірте, чи це PEM-файл з delimiters BEGIN/END PUBLIC KEY.');
                } else if (errorMessage.includes('Unable to load PEM file') || errorMessage.includes('MalformedFraming')) {
                    showError('verify-public-key-error', 'Помилка верифікації: Невірний або пошкоджений публічний ключ. Спробуйте згенерувати новий.');
                } else {
                    showError('verify-data-error', `Помилка верифікації: ${errorMessage}`);
                }
            }
        });
    </script>
</body>
</html>